/*--------------------------------------------------------------------
 * $Id: phase.c 3262 2017-03-21 14:43:10Z Claudia.Emde $
 * 
 * This file is part of libRadtran.
 * Copyright (c) 1997-2012 by Arve Kylling, Bernhard Mayer,
 *                            Claudia Emde, Robert Buras
 *
 * ######### Contact info: http://www.libradtran.org #########
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License   
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.        
 * 
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of  
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the   
 * GNU General Public License for more details.                    
 * 
 * You should have received a copy of the GNU General Public License          
 * along with this program; if not, write to the Free Software                
 * Foundation, Inc., 59 Temple Place - Suite 330, 
 * Boston, MA 02111-1307, USA.
 *--------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <getopt.h>

#include "ascii.h"
#include "miecalc.h"

#if HAVE_LIBNETCDF
#include <netcdf.h>
#endif

#ifndef PI
#define PI 3.14159265358979323846264338327
#endif


#define PROGRAM "phase"
#define VERSION "0.8a"

#define MAXLINE 255

/*
  Documentation in latex for the User's Guide. Extracted by sdoc2.awk 
  and input in the doc/tools.tex.
*/
/*
  <lpdoc>

\subsection{Calculate phase function from Legendre polynomials - \codeidx{phase}}
\label{sec:phase}

The \code{phase} tool takes a Legendre series as input and calculates
the corresponding phase function. 

The program is invoked as follows:
 \begin{Verbatim}[fontsize=\footnotesize]
  phase [options] <filename>
\end{Verbatim}

The following optional arguments may be specified:
\begin{description}
\item[-h] Display help message.
\item[-c] 1-column input.
\item[-b] Binary (netcdf) input.
\item[-d] Use scattering angle in degrees instead of the cosine of the
scattering angle $\mu$.
\item[-s $<$step$>$] Step width for evaluation (default: 0.01).
\item[-o]$<$number of digits$>$ Optimize scattering angle grid.
\item[-x $<$filename$>$] File containing $\mu$-values to be
interpolated.
\item[-n] Normalize phase function. 
\item[-f] Use delta scaling. 
\end{description}

The format of the input file is as generated by the \code{mie} program.
the first 7 columns are ignored, the following columns are
assumed to hold the moments of the phase function. If option
\code{-c} is specified, the input file is considered a one column file
holding one moment per line.

</lpdoc>
*/


/*************************************************************/
/* print usage information                                   */
/*************************************************************/

static void print_usage (char *filename)
{
  fprintf (stderr, "%s %s - evaluate phase function\n\n", PROGRAM, VERSION);
  fprintf (stderr, "written by  Bernhard Mayer,\n");
  fprintf (stderr, "            DLR, e-Mail bernhard.mayer@dlr.de\n");
  fprintf (stderr, "Version %s finished July 26, 2000\n\n", VERSION);
  fprintf (stderr, "Be aware that this program is an beta version! Please report any\n");
  fprintf (stderr, "kind of error to the author, including the error message and the\n");
  fprintf (stderr, "data being processed when the error occured. Thanks!\n\n");
  fprintf (stderr, "USAGE: %s [options] <filename>\n\n", filename);
  fprintf (stderr, "Optional arguments:\n");
  fprintf (stderr, "  -h            display help message\n");
  fprintf (stderr, "  -c            1-column input\n");
  fprintf (stderr, "  -b            binary (netcdf) input (mie tool format)\n");
  fprintf (stderr, "  -d            use angle [degrees] instead of mu\n");
  fprintf (stderr, "  -s <step>     step width for evaluation (default: 0.01)\n");
  fprintf (stderr, "  -o <digits>   optimize scattering angle grid \n");
  fprintf (stderr, "  -x <filename> file containing mu-values to be interpolated\n");
  fprintf (stderr, "  -n            normalize phase matrix\n");
  fprintf (stderr, "  -f            use delta scaling\n\n"); 
  fprintf (stderr, "%s calculates the phase function p(mu) from the moments of the phase\n", PROGRAM);
  fprintf (stderr, "for an equidistant mu grid.\n");
  fprintf (stderr, "The format of the input file is as generated by the \"mie\" program\n");
  fprintf (stderr, "(the first 7 columns are ignored, the following columns are\n");
  fprintf (stderr, " assumed to hold the moments of the phase function). If option\n");
  fprintf (stderr, "\"-c\" is specified, the input file is considered a one column file,\n");
  fprintf (stderr, "holding one moment per line. If option \"-b\" is specified,\n");
  fprintf (stderr, "the format of the input file must be in netcdf (binary) format,\n");
  fprintf (stderr, "the output in this case is a file in netcdf format called phase.nc. \n");
}

int legendre2phase(double *f, int L, char deltascaling, char normalize, 
                   int optimize, char degrees, 
                   char netcdf, char *mufilename, double step, 
                   double **xgrid, double **phase);

#if HAVE_LIBNETCDF
int read_netcdf(char *infilename, float ****legen, int **nleg, double **reff, 
                size_t *nphamat, size_t *nreff);

int write_netcdf(char *filename, double ***phase_array, double *reff, 
                 int nreff, int nphamat, int* nleg, double *xgrid, int nmu);
#endif 

static double mom2phaseint (double x, double *f, int n);


/*************************************************************/
/* parse command line options                                */
/*************************************************************/

static int get_options (int argc, char **argv,
			char *programname,
			char *infilename,
			char *onecolumn,
                        char *netcdf,
			double *step,
			char *degrees,
                        int *optimize,
			char *mufilename,
                        char *normalize,
			char *deltascaling)
{
  int c=0;
  char *dummy=NULL;

  /* save name of program */
  strncpy (programname, argv[0], FILENAME_MAX);

  /* set defaults */
  strcpy (infilename, "");
  *onecolumn=0;
  *step=0.01;
  *degrees=0;
  *deltascaling=0;
  *normalize=0;
  *optimize=0;

  while ((c=getopt (argc, argv, "hcbdo:s:x:nf")) != EOF)  {
    switch(c)  {
    case 'h':  /* help */
      print_usage (programname);
      return (-1);
      break;
    case 'c':  /* one column input */
      *onecolumn=1;
      break;
    case 'b': /* binary (netcdf) input */
#if HAVE_LIBNETCDF  
      *netcdf = 1;
#else
      fprintf (stderr, " ***********************************************************************\n");
      fprintf (stderr, " * You have built phase without libnetcdf and hence cannot             *\n");
      fprintf (stderr, " * use the option '-b'. Please get netcdf and rebuild.                 *\n");
      fprintf (stderr, " ***********************************************************************\n");
      return -1;
#endif
      break;
    case 'd':  /* degrees instead of mu */
      *degrees=1;
      break;
    case 's':  /* step width*/
      *step = strtod (optarg, &dummy);
      break;
    case 'x':  /* step width*/
      strcpy (mufilename, optarg);
      break;
    case 'o':
      *optimize= strtol (optarg, &dummy, 10);
      break;
    case 'n':  /* normalize phase matrix */
      *normalize=1;
      break;
    case 'f':  /* delta scaling */
      *deltascaling=1;
      break; 
    default:
      print_usage (programname);
      return (-1);
    }
  }
      

  /* check number of remaining command line arguments */
  if (argc - optind != 1)  {
    print_usage (programname);
    return -1;
  }
  
  strncpy (infilename, argv[optind+0], FILENAME_MAX);

  return 0;  /* if o.k. */
}


int main(int argc, char **argv)
{
  int status=0, l=0;

  double *f=NULL;
    
  char mufilename[FILENAME_MAX]="";

  int L=0;

  double step=0;
  
  char onecolumn=0, netcdf=0, degrees=0, deltascaling=0, 
    normalize=0;
  
  int optimize=0;

  char programname[FILENAME_MAX], infilename[FILENAME_MAX]="";

  double **value=NULL;
  int rows=0, min_columns=0, max_columns=0;
  
  double *xgrid=NULL, *phase=NULL; 
  int nmu=0;
  
  double *xgrid_opt=NULL, *phase_opt=NULL; 
  int nmu_opt=0;
  int warning=0; 

#if HAVE_LIBNETCDF
  size_t nreff=0, nphamat=0;
  float ***legen;
  double *reff=NULL;
  int *nleg=NULL; 
  int ir=0, ip=0, im=0;
  
  double ***phase_array;
  double *mu_user=NULL;
  double xmin=0, xmax=0;
 
#endif
  
  /* get command line options */
  status = get_options (argc, argv, programname, infilename, &onecolumn, &netcdf,
                        &step, &degrees, &optimize, mufilename, &normalize, &deltascaling);
  
  if (status!=0)
    return status;

  if(optimize>0){
    fprintf(stderr, " ... find optimized scattering angle grid in degrees (options to set up another grid ignored)\n");
    fprintf(stderr, " ... use %d digits for optimization.\n", optimize);  
    
    if(optimize==3){
      step=0.001;
      nmu=180001;
    }
    else if (optimize==2){
      step=0.01;
      nmu=18001;
      }
    else{
      fprintf (stderr, "Warning: Number of digits for grid optimization should be 2 or 3, \n");
      fprintf (stderr, "         You have specified %d, the default of 2 digits is used.\n", optimize);
      step=0.01;
      nmu=18001;
    }
         
      
    xgrid = calloc (nmu, sizeof(double));
    phase = calloc (nmu, sizeof(double));
    xgrid_opt = calloc (nmu, sizeof(double));
    phase_opt = calloc (nmu, sizeof(double));
    degrees=1;
  }


  if(!netcdf){
    if (onecolumn) {
      status = read_1c_file (infilename, &f, &L);
      
      fprintf (stderr, " ... read %d coefficients from %s\n", L, infilename);
      
      if (status!=0) {
        fprintf (stderr, "error %d reading %s\n", status, infilename);
        return status;
      }
    }
    else{
      status = ASCII_file2double (infilename,    
                                  &rows,       
                                  &max_columns,
                                  &min_columns,
                                  &value);     
      
      if (status!=0) {
        fprintf (stderr, "error %d reading %s\n", status, infilename);
        return status;
      }

      if (min_columns!=max_columns)
        fprintf (stderr, "ATTENTION: inconsistent number of columns, %d - %d\n",
                 min_columns, max_columns);
      
      L = min_columns-7;
      
      fprintf (stderr, " ... read %d lines with %d coefficients each from %s\n", 
               rows, L, infilename);
      
      if (rows>1)
        fprintf (stderr, " ... processing only 1st line!\n");
      
      
      /* copy first line to work array */
      f = calloc (L, sizeof(double));
      for (l=0; l<L; l++)
        f[l] = value[0][l+7];
    }
    legendre2phase(f, L,  deltascaling, normalize, optimize, degrees, netcdf,
                   mufilename, step, &xgrid, &phase); 
    if (status!=0) {
      fprintf (stderr, "Error %d in function legendre2phase", status);
      return status;
    }
    
    if(optimize){
      for (l=0; l<nmu; l++){
        xgrid[l]=cos(xgrid[l]*PI/180);
      }

      optimize_theta_grid(&xgrid_opt, &phase_opt, &nmu_opt, xgrid, phase, nmu, 0.01, 1000, &warning);
      
      for (l=0; l<nmu_opt; l++)
        printf("%10.3f %.10e \n", acos(xgrid_opt[l])*180/PI, phase_opt[l]); 
    }
    
  }
  
#if HAVE_LIBNETCDF
  else { /* netcdf */
    status=read_netcdf(infilename, &legen, &nleg, &reff, &nphamat, &nreff);
    if (status!=0) {
      fprintf (stderr, "Error %d in function read_netcdf\n", status);
      return status;
    }
    
    /* read user mu data, need this information (nmu) to allocate memory for phase_array. */
    if (strlen(mufilename)>0) {
      fprintf (stderr, " ... reading interpolation grid from %s\n", mufilename);
      
      /* read file with user mu values */
      status = read_1c_file (mufilename, &mu_user, &nmu);
      if (status!=0)  {
        fprintf (stderr, "Error reading file %s\n", mufilename);
        return (-1);
      }
      if (degrees) {
	for (im=0; im<nmu; im++)
	  mu_user[im]=cos(mu_user[im]/180.*PI);
      }
    }
    else{
      if (degrees) {
        xmin=0.0;
        xmax=180.00000001;
      }
      else {
        xmin=-1.0;
        xmax=1.00000000001;
      }
      nmu=(xmax-xmin)/step+1; 
    }
    
    status = ASCII_calloc_double_3D(&phase_array, nreff, nphamat, nmu);
    if (status!=0) {
      fprintf (stderr, "Error allocating variable phase_array.\n");
      return status;
    } 
    
    for (ir=0; ir<nreff; ir++){
      fprintf(stdout, "Effective radius: %f \n", reff[ir]);
      f = calloc (nleg[ir], sizeof(double));
      for (ip=0; ip<nphamat; ip++){
        for (im=0; im<nleg[ir]; im++){
          f[im]=legen[ir][ip][im];
        } 
        legendre2phase(f, nleg[ir], deltascaling, normalize, optimize, degrees, netcdf,
                       mufilename, step, &xgrid, &phase); 
        phase_array[ir][ip]=phase;
      }
    }

    status=write_netcdf("phase.nc", phase_array, reff, nreff, nphamat, nleg, xgrid, nmu);
    if (status!=0) {
      fprintf (stderr, "Error writing netcdf file.\n");
      return status;
    } 
  }
#endif

  return 0;
}

/***********************************************************************************/
/* Function: legendre2phase                                                        */
/* Description:                                                                    */
/*  Calculate the phase function from the Legendre polynomials.                    */
/*                                                                                 */
/* Parameters:                                                                     */
/*                                                                                 */
/* Input:                                                                          */
/*                                                                                 */
/*  f             Legendre polynomials                                             */
/*  L             number of Legendre polynomials                                   */
/*  deltascaling  if true, phase function will be deltaM-scaled                    */
/*  normalize     if true, phase function integral is normalized to 2              */
/*  degrees       if true, output angles are in degrees                            */
/*  netcdf        if true, a netcdf file is generated instead of ascii             */
/*  mufilename    filename of angular grid                                         */
/*  step          step-width of angular grid                                       */
/*                                                                                 */
/* Output:                                                                         */
/*                                                                                 */
/*  xgrid         angular grid                                                     */
/*  phase         phase function                                                   */
/*                                                                                 */
/*  Return value:                                                                  */
/*  0  if o.k., <0 if error                                                        */
/*                                                                                 */
/* Example:                                                                        */
/* Files:                                                                          */
/* Known bugs:                                                                     */
/*                                                                                 */
/* Author: Bernhard Mayer                                                          */
/*         Claudia Emde (included normalization, deltascaling, and netcdf          */
/*                       optimization of scattering angle grid)                    */
/*                                                                                 */
/***********************************************************************************/
int legendre2phase(double *f, int L, char deltascaling, char normalize, 
                   int optimize, char degrees, 
                   char netcdf, char *mufilename, double step, 
                   double **xgrid, double **phase)
{
  int status=0, l=0;
  
  int i=0;

  double sum=0, sumint=0, factor=0;
  
  double x=0, xx=0;

  double xmin=0, xmax=0;

  int imu=0, nmu=0;
  
  double *mu_user=NULL;

  /* delta scaling */
  if(deltascaling) {
    for (l=0; l<L; l++)
      f[l]=(f[l]-f[L-1])/(1-f[L-1]);
  }
  
  /* multiply by (2l+1) to convert from 'moments of the phase function' */
  /* to Legendre coefficients;                                          */
  if(!netcdf){
    for (l=0; l<L; l++)
      f[l] *= (double) (2*l+1);
  }
  
  /* normalize */
  if(normalize){
    factor = 1.0 / f[0];
    for (l=0; l<L; l++)
      f[l] *= factor;
  }

  /* read user mu data */
  if (strlen(mufilename)>0 && !optimize) {
    fprintf (stderr, " ... reading interpolation grid from %s\n", mufilename);
    
    /* read file with user mu values */
    status = read_1c_file (mufilename, &mu_user, &nmu);
    if (status!=0)  {
      fprintf (stderr, "Error reading file %s\n", mufilename);
      return (-1);
    }
    
    if(netcdf){
      *xgrid = calloc (nmu, sizeof(double));
      *phase = calloc (nmu, sizeof(double));
    }

    for (imu=0; imu<nmu; imu++) {
      
      if (degrees) {
	if (mu_user[imu]<0 || mu_user[imu]>180) {
	  fprintf (stderr, "Error, mu = %f out of range\n", mu_user[imu]);
	  return -1;
	}
      }
      else {
	if (mu_user[imu]<-1 || mu_user[imu]>1) {
	  fprintf (stderr, "Error, mu = %f out of range\n", mu_user[imu]);
	  return -1;
	}
      }
    }
  }

  
  if (strlen(mufilename)>0) {   /* user-defined mu */
    for (imu=0; imu<nmu; imu++) {

      x = mu_user[imu];

      if (degrees)  /* convert to mu=cos(theta) */
	x = cos(x/180.0*PI);
      
      sum    = mom2phase    (x, f, L);
      sumint = mom2phaseint (x, f, L);
      
      if(netcdf){
        /* write arrays*/
        if (degrees)
          *xgrid[i]=acos(x)/PI*180.0;
        else
          *xgrid[i]=x;

        *phase[i]=sum; 
        i++;
      }
      else{
        if (degrees)
          fprintf (stdout, "%12.8f %.10e %.10e\n", acos(x)/PI*180.0, sum, sumint);
        else
          fprintf (stdout, "%.8f %.10e %.10e\n", x, sum, sumint);
      }
    }
  }
  else {   /* fixed grid */

    if (degrees || optimize) {
      xmin=0.0;
      xmax=180.00000001;
    }
    else {
      xmin=-1.0;
      xmax=1.00000000001;
    }
    
    if(netcdf){
      nmu=(xmax-xmin)/step+1; 
      *xgrid = calloc (nmu, sizeof(double));
      *phase = calloc (nmu, sizeof(double));
    }
    
    i=0; 
    for (xx=xmin; xx<=xmax; xx+=step) {
      
      if (degrees)  /* convert to mu=cos(theta) */
	x = cos(xx/180.0*PI);
      else 
	x = xx;

      sum    = mom2phase    (x, f, L);
      sumint = mom2phaseint (x, f, L);

      if(optimize){
        (*xgrid)[i]=acos(x)/PI*180.;
        (*phase)[i]=sum; 
      }      
      else if(netcdf){
        
        /* write arrays*/
        if (degrees)
	  (*xgrid)[i]=acos(x)/PI*180.0;
        else
          (*xgrid)[i]=x;

        (*phase)[i]=sum;
      }
      else{
        
        if (degrees)
          fprintf (stdout, "%12.8f %.10e %.10e\n", acos(x)/PI*180.0, sum, sumint);
        else
          fprintf (stdout, "%.8f %.10e %.10e\n", x, sum, sumint);
      }
      i++;
    }
  }

  if (strlen(mufilename)>0)
    free (mu_user);
  
  return 0;
}


/* calculate integral of the phase function from -1 to x from the phase function moments */
static double mom2phaseint (double x, double *f, int L) {

  int l=0;
  
  double sum=0;
  double pl=0, plm1=0, plm2=0;
  double pldash=0, pldashm1=0, pldashm2=0;

  plm2 = 1;
  plm1 = x;
  
  pldashm2 = 0;
  pldashm1 = 1;
  
  sum = (1.0-x)*f[0] + 0.5*(1.0-x*x)*f[1];
  
  for (l=2; l<L; l++) {
    pl     = ((double) (2*l-1) * x * plm1 - (double) (l-1) * plm2) / (double) l;
    pldash = ((double) (2*l-1) * (plm1 + x * pldashm1) - (double) (l-1) * pldashm2) / (double) l;
    
    sum += f[l] * (1.0-x*x) / (double)(l*(l+1)) * pldash;
    
    plm2=plm1;
    plm1=pl;
    
    pldashm2=pldashm1;
    pldashm1=pldash;
  }
  
  return (2.0-sum);  /* we want -1 to x, not x to 1 */
}
  


#if HAVE_LIBNETCDF
/** 
 * read_netcdf
 *
 * Read scattering properties file in netcdf format (the same format
 * as generated by "mie" and as used in "uvspec"). 
 * All field are read but not yet used. "phase" could eventually be 
 * extended to extract different fields from the netcdf file. 
 * 
 * @param infilename netcdf filename
 * @param pmom Legendre polynomials
 * @param reff Effective radii
 * @param nphamat Number of phase matrix elements
 *
 * @return status
 *
 * @author Claudia Emde
 **/
int read_netcdf(char *infilename, float ****legen, int **nleg, double **reff, 
                size_t *nphamat, size_t *nreff)
{
  int ncid=0;
  int status=0;

  int idd_reff=0, idd_maxmom=0, idd_nphamat=0;
  int id_reff=0, id_ext=0, id_ssa=0, id_nmom=0, id_pmom=0;
  int id_wavelen=0; 
  int new_format=1;

  int i=0, ip=0, im=0;
  size_t maxmom;

  size_t start[1] = {0};
  size_t count[1] = {0};

  size_t start3D[3] = {0,0,0}; /*reff, nstokes, nmom*/
  size_t start2D[2] = {0,0}; /*reff, nstokes, nmom*/

  double *extinc=NULL, *albedo=NULL;
  double wavelen=0; 

  /* open netcdf file */
  status = nc_open (infilename, NC_NOWRITE, &ncid);
  if (status!=NC_NOERR) {
    fprintf (stderr, "Error: Cannot open netCDF file %s, using\n",
             infilename);
  }
  
  /* get dimension id for "maxmom" */
  status = nc_inq_dimid (ncid, "maxmom", &idd_maxmom);
  if (status!=NC_NOERR) {
    fprintf (stderr, "Error %d reading maxmom id from %s\n", status, infilename);
    return status;
  }
  
  /* get dimension length for "maxmom" */
    status = nc_inq_dimlen (ncid, idd_maxmom, &maxmom);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading maxmom from %s\n", status, infilename);
      return status;
    }

    /* get dimension id for "reff" */
    status = nc_inq_dimid (ncid, "reff", &idd_reff);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading reff id from %s, try hum id\n", status, infilename);
      status = nc_inq_dimid (ncid, "hum", &idd_reff);
      if (status!=NC_NOERR) {
        fprintf (stderr, "Error %d reading hum id from %s\n", status, infilename); 
        return status;
      }
    }
    
    /* get dimension length for "reff" */
    status = nc_inq_dimlen (ncid, idd_reff, nreff);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading reff from %s\n", status, infilename);
      return status;
    }
    
    /* get dimension id for "nphamat" */
    status = nc_inq_dimid (ncid, "nphamat", &idd_nphamat);
    if (status!=NC_NOERR) {
      fprintf (stderr, "*** Warning: nphamat not found in netcdf file %s. Assume old \n",infilename);
      fprintf (stderr, "***          dataformat, where only phase function moments are included. \n");
      *nphamat=1;
      new_format=0; 
    }
    
    if(new_format){
      /* get dimension length for "nphamat" */
      status = nc_inq_dimlen (ncid, idd_nphamat, nphamat);
      if (status!=NC_NOERR) {
        fprintf (stderr, "Error %d reading nphamat from %s\n", status, infilename);
        return status;
      }
    }
    
    /* allocate memory for fields */
    *reff    = calloc (*nreff, sizeof(double));
    extinc = calloc (*nreff, sizeof(double));
    albedo = calloc (*nreff, sizeof(double));
    *nleg   = calloc (*nreff, sizeof(int));
    
    count[0] = *nreff;
    
    /* get variable id for "reff" */
    status = nc_inq_varid (ncid, "reff", &id_reff);
    if (status!=NC_NOERR) {
      status = nc_inq_varid (ncid, "hum", &id_reff);
      if (status!=NC_NOERR) {
        fprintf (stderr, "Error %d reading reff/hum %s\n", status, infilename);
        return status;
      }
    }

    /* get variable id for "ext" */
    status = nc_inq_varid (ncid, "ext", &id_ext);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }


    /* get variable id for "ssa" */
    status = nc_inq_varid (ncid, "ssa", &id_ssa);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

  
    /* get variable id for "nmom" */
    status = nc_inq_varid (ncid, "nmom", &id_nmom);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

  
    /* get variable id for "pmom" */
    status = nc_inq_varid (ncid, "pmom", &id_pmom);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

  
    /* get variable id for "wavelen" */
    status = nc_inq_varid (ncid, "wavelen", &id_wavelen);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

    /* (CE) The refractive index is not used in uvspec. Commented this
       because for aerosols the refractive index varies with 
       relative humidity. */
    /* get variable id for "nre" */
    /*status = nc_inq_varid (ncid, "nre", &id_nre);
      if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
      }
    */

    /* get variable id for "nim" */
    
    /*status = nc_inq_varid (ncid, "nim", &id_nim);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }
    */

    /* read "wavelen" */
    status = nc_get_var1_double (ncid, id_wavelen, start, &wavelen);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

    /* convert wavelength from micron to nm */
    wavelen*=1000.0;

    
    /* read "nre" */

    /*status = nc_get_var1_double (ncid, id_nre, start, nre);
      if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
      }
    */
    
    /* read "nim" */
    /*status = nc_get_var1_double (ncid, id_nim, start, nim);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }
    */ 
    
    /* read "reff" */
    status = nc_get_vara_double (ncid, id_reff, start, count, *reff);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }
    
    /* read "ext" */
    status = nc_get_vara_double (ncid, id_ext, start, count, extinc);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

    /* read "ssa" */
    status = nc_get_vara_double (ncid, id_ssa, start, count, albedo);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    }

    /* read "nmom" */
    status = nc_get_vara_int (ncid, id_nmom, start, count, *nleg);
    if (status!=NC_NOERR) {
      fprintf (stderr, "Error %d reading %s\n", status, infilename);
      return status;
    } 
    
    status = ASCII_calloc_float_3D(legen, *nreff, *nphamat, maxmom);
    if (status!=0) {
      fprintf (stderr, "Error allocating variable legen in miecalc.c.s\n");
      return status;
    } 
    
    if(new_format){
     
      for (i=0; i<*nreff; i++){
        for (ip=0; ip<*nphamat; ip++){
          for (im=0; im<(*nleg)[i]; im++){
            /* allocate and read Legendre polynomials */
            start3D[0]=i; 
            start3D[1]=ip;
            start3D[2]=im; 
            status = nc_get_var1_float (ncid, id_pmom, start3D, 
                                        &((*legen)[i][ip][im]));
            if (status != 0) {
              fprintf (stderr, "Error %d reading Legendre polynoms from netCDF file %s \n", status, infilename);
              return status;
            }
            /*fprintf(stderr, "(*legen)[i][ip][im] %d %d %d  %g \n",i, ip, im, (*legen)[i][ip][im]); */
          }
        }
      }
    }
    
    else{
      for (i=0; i<*nreff; i++){
        for (im=0; im<(*nleg)[i]; im++){
          /* allocate and read Legendre polynomials */
          start2D[0]=i; 
          start2D[1]=im;
          status = nc_get_var1_float (ncid, id_pmom, start2D, 
                                      &((*legen)[i][0][im]));
          if (status != 0) {
            fprintf (stderr, "Error %d reading Legendre polynoms from netCDF file %s \n", status, infilename);
            return status;
          }
        }
      }
    } 
    
    nc_close(ncid);
    
    /* Check number of phase matrix elements. */
    if (*nphamat!=1 && *nphamat!=6){
      fprintf(stderr, "Error, number of phase matrix elements in %s must be either 1 or 6\n", infilename);
      fprintf(stderr, "       but the file includes the polynomials for %zd phase matrix elements.\n", *nphamat);
      return -1; 
    }
  
    
    return 0; 
}


int write_netcdf(char *filename, double ***phase_array, double *reff, 
                 int nreff, int nphamat, int *nleg, double *mu, int nmu)
{
  int retval=0;
  int ncid=0;


  int id_nreff=0, id_nphamat=0, id_nmu=0;
  int dimids[3];
  
  int id_reff=0, id_mu=0, id_phase=0;
  
  double *phase=NULL;
  int ir=0, im=0, ip=0, i=0;
  char name[MAXLINE], unit[16], varname[10];

  /* Create a 1D array for netcdf output */  
  phase = calloc(nreff * nphamat * nmu, sizeof(double));
  
  i=0;
  for (ir=0; ir<nreff; ir++){
    for (ip=0; ip<nphamat; ip++){
      for (im=0;im<nmu; im++){
        phase[i]=phase_array[ir][ip][im];
        i++;
      }
    }
  }
  
  
  if ((retval = nc_create(filename, NC_CLOBBER, &ncid)))
    {
      fprintf(stderr, "Error: creating netcdf file");
      return -1;
    }

  strcpy(name, "Netcdf file created using libRadtran-phase-tool");
  nc_put_att_text(ncid, NC_GLOBAL, "file_info", strlen(name), name);
  
  /* Define dimensions.*/
  if ((retval = nc_def_dim(ncid, "reff", nreff, &id_nreff))){
       fprintf(stderr, "Error: creating dimension nreff.\n" );
       return -1;
  }
  
  if ((retval = nc_def_dim(ncid, "nphamat", nphamat, &id_nphamat))){
    fprintf(stderr, "Error: creating dimension nphamat.\n" );
    return -1;
  }
  
  if ((retval = nc_def_dim(ncid, "mu", nmu, &id_nmu))){
    fprintf(stderr, "Error: creating dimension nmu.\n" );
    return -1;
  }
  
  /* Define variables */
  
  /* effective radius */
  strcpy(varname,"reff");
  strcpy(name,"effective radius");
  strcpy(unit,"micrometer");
  if ((retval = nc_def_var(ncid, varname, NC_DOUBLE, 1, 
                            &id_nreff, &id_reff))){
     fprintf(stderr, "Error: defining variable reff. \n");
     return -1;
  } 
  nc_put_att_text(ncid, id_reff, "long_name", strlen(name), name);  
  nc_put_att_text(ncid, id_reff, "units", strlen(unit), unit);
  
  /* x values */
  /* mu */
  strcpy(varname,"mu");
  /* strcpy(name,"scattering angle");         */
  /* strcpy(unit,"cos(degrees) or degrees");  */
  if ((retval = nc_def_var(ncid, varname, NC_DOUBLE, 1, 
                           &id_nmu, &id_mu))){
    fprintf(stderr, "Error: defining variable mu. \n");
    return -1;
  } 
  /* nc_put_att_text(ncid, id_mu, "long_name", strlen(name), name); */
  /* nc_put_att_text(ncid, id_mu, "units", strlen(unit), unit);     */


  /* phase function */
  dimids[0] = id_nreff;
  dimids[1] = id_nphamat;
  dimids[2] = id_nmu;
  if ((retval = nc_def_var(ncid, "phase", NC_DOUBLE, 3, 
                           dimids, &id_phase))){
    fprintf(stderr, "Error: defining variable pmom. \n");
    return -1;
  } 
  strcpy(name,"phase matrix");
  strcpy(unit," ");
  nc_put_att_text(ncid, id_phase, "long_name", strlen(name), name);  
  nc_put_att_text(ncid, id_phase, "units", strlen(unit), unit);
  
  /* End define mode. This tells netCDF we are done defining
   * metadata. */ 
  if ((retval = nc_enddef(ncid))){
     fprintf(stderr, "Error: netcdf definition end. \n");
     return -1;
  } 

  /* write variables */

  if ((retval = nc_put_var_double(ncid, id_reff, &reff[0]))){ 
    fprintf(stderr, "Error: writing variable reff.\n"); 
    return -1; 
  }  
  
  if ((retval = nc_put_var_double(ncid, id_mu, &mu[0]))){ 
    fprintf(stderr, "Error: writing variable mu.\n"); 
    return -1; 
  }  
   
  if ((retval = nc_put_var_double(ncid, id_phase, &phase[0]))){ 
     fprintf(stderr, "Error: writing variable phase.\n"); 
     return -1; 
   }  
   
  /* Close the file. This frees up any internal netCDF resources
   * associated with the file, and flushes any buffers. */
  if ((retval = nc_close(ncid))){
    fprintf(stderr, "Error: closing netcdf file.\n");
    return -1;
  } 
  
  return 0;
}


#endif
  

  
